{"pages":[],"posts":[{"title":"scoped_model 源码阅读","text":"最近做的项目有一个需求, 就是有不同的主题, 那么在设置页面就应该让生效, 这就是全局状态的一个管理了, Flutter 系统提供了 InheritedWidget, 但是这里我们来使用 scoped_model(基于InheritedWidget进行了封装). InheritedWidget我们先来看一下InheritedWidget是如何实现共享数据的. 以下是官网上的一个小例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class ShareDataWidget extends InheritedWidget &#123; ShareDataWidget(&#123; @required this.data, Widget child &#125;) :super(child: child); final int data; //需要在子树中共享的数据，保存点击次数 //定义一个便捷方法，方便子树中的widget获取共享数据 static ShareDataWidget of(BuildContext context) &#123; return context.inheritFromWidgetOfExactType(ShareDataWidget); &#125; //该回调决定当data发生变化时，是否通知子树中依赖data的Widget @override bool updateShouldNotify(ShareDataWidget old) &#123; //如果返回true，则子树中依赖(build函数中有调用)本widget //的子widget的`state.didChangeDependencies`会被调用 return old.data != data; &#125;&#125;class _TestWidget extends StatefulWidget &#123; @override __TestWidgetState createState() =&gt; new __TestWidgetState();&#125;class __TestWidgetState extends State&lt;_TestWidget&gt; &#123; @override Widget build(BuildContext context) &#123; //使用InheritedWidget中的共享数据 return Text(ShareDataWidget .of(context) .data .toString()); &#125; @override void didChangeDependencies() &#123; super.didChangeDependencies(); //父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。 //如果build中没有依赖InheritedWidget，则此回调不会被调用。 print(\"Dependencies change\"); &#125;&#125;class InheritedWidgetTestRoute extends StatefulWidget &#123; @override _InheritedWidgetTestRouteState createState() =&gt; new _InheritedWidgetTestRouteState();&#125;class _InheritedWidgetTestRouteState extends State&lt;InheritedWidgetTestRoute&gt; &#123; int count = 0; @override Widget build(BuildContext context) &#123; return Center( child: ShareDataWidget( //使用ShareDataWidget data: count, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.only(bottom: 20.0), child: _TestWidget(),//子widget中依赖ShareDataWidget ), RaisedButton( child: Text(\"Increment\"), //每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新 onPressed: () =&gt; setState(() =&gt; ++count), ) ], ), ), ); &#125;&#125; 这里需要注意: context.inheritFromWidgetOfExactType(ShareDataWidget)来获取到指定InheritedWidget中的数据, 实际通知的时候是父Widget往下传递还是子Widget往上遍历呢? 接下lai 探索原因 InheritedWidget的源码很简单, 继承了ProxyWidget, 也没有实现太多逻辑, 对createElement进行了实现, 还定义了updateShouldNotify, 该方法的意思就是更新的时候是否应该通知在 build 阶段通过inheritFromWidgetOfExactType查找该 Widget 的子 Widget. 12345678910abstract class InheritedWidget extends ProxyWidget &#123; const InheritedWidget(&#123; Key key, Widget child &#125;) : super(key: key, child: child); @override InheritedElement createElement() =&gt; InheritedElement(this); @protected bool updateShouldNotify(covariant InheritedWidget oldWidget);&#125; 顺藤摸瓜, 我们去就去看InheritedElement(this)做了什么, 进去之后我们可以发现_updateInheritance方法. 123456789void _updateInheritance() &#123; assert(_active); final Map&lt;Type, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets; if (incomingWidgets != null) _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;.from(incomingWidgets); else _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;(); _inheritedWidgets[widget.runtimeType] = this;&#125; 同时我们对比一下普通的Element的该方法实现, 只是简单的将父Element的_inheritedWidgets属性保存到自身(这样就保证了父级的向子集传递特性). 1234void _updateInheritance() &#123; assert(_active); _inheritedWidgets = _parent?._inheritedWidgets;&#125; 但是这个_inheritedWidgets属性又是在哪里出现呢? 它定义在 Element中, 每一个实例都有这个属性. 它的作用是存储上级节点Widget和Element之间的映射. 1234567891011abstract class Element extends DiagnosticableTree implements BuildContext &#123; /// Creates an element that uses the given widget as its configuration. /// /// Typically called by an override of [Widget.createElement]. Element(Widget widget) : assert(widget != null), _widget = widget; Element _parent;...Map&lt;Type, InheritedElement&gt; _inheritedWidgets; 现在我们回到InheritedElement的实现. 12345678910void _updateInheritance() &#123; assert(_active); final Map&lt;Type, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets; if (incomingWidgets != null) _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;.from(incomingWidgets); else _inheritedWidgets = HashMap&lt;Type, InheritedElement&gt;(); // 添加 _inheritedWidgets[widget.runtimeType] = this;&#125; InheritedElement会将自身的信息添加到_inheritedWidgets属性中, 然后子孙都可以通过他们自身的该属性访问当前的InheritedElement了. 现在我们知道如何访问_inheritedWidgets属性以及包含的内容了, 那么通知机制是如何实现呢? 一开始例子中就是使用inheritFromWidgetOfExactType(Type)方法去获取到指定的InherientWidget的, 那么这个方法是怎么实现呢? 12345678910111213141516171819InheritedWidget inheritFromWidgetOfExactType(Type targetType, &#123; Object aspect &#125;) &#123; assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; if (ancestor != null) &#123; assert(ancestor is InheritedElement); return inheritFromElement(ancestor, aspect: aspect); &#125; _hadUnsatisfiedDependencies = true; return null;&#125;@overrideInheritedWidget inheritFromElement(InheritedElement ancestor, &#123; Object aspect &#125;) &#123; assert(ancestor != null); _dependencies ??= HashSet&lt;InheritedElement&gt;(); _dependencies.add(ancestor); ancestor.updateDependencies(this, aspect); return ancestor.widget;&#125; 首先会获取Element(Context)的_inheritedWidgets指定类型的Element, 如果获取到了, 则会添加到自身的依赖列表中, 祖先节点也有记录这个依赖, 这样在更新时候就可以直接通过_dependencies属性来进行通知了. 每一次InherientElement更新的时候, 都会调用notifyClients方法来通知子节点, 调用子节点的didChangeDependencies方法 1234567891011121314151617void notifyClients(InheritedWidget oldWidget) &#123; if (!widget.updateShouldNotify(oldWidget)) return; assert(_debugCheckOwnerBuildTargetExists('notifyClients')); for (Element dependent in _dependents) &#123; assert(() &#123; // check that it really is our descendant Element ancestor = dependent._parent; while (ancestor != this &amp;&amp; ancestor != null) ancestor = ancestor._parent; return ancestor == this; &#125;()); // check that it really depends on us assert(dependent._dependencies.contains(this)); dependent.didChangeDependencies(); &#125;&#125; 以上就是InherientWidget的原理, 接下来就是看看scoped_model做了怎样的封装. scoped_model该库主要的类有: abstract class Model extends Listenable12345678910111213141516171819202122232425262728293031abstract class Model extends Listenable &#123; final Set&lt;VoidCallback&gt; _listeners = Set&lt;VoidCallback&gt;(); int _version = 0; int _microtaskVersion = 0; void addListener(VoidCallback listener) &#123; debugPrint(\"添加监听器\"); listener(); _listeners.add(listener); &#125; @override void removeListener(VoidCallback listener) &#123; print(\"监听器被去除\"); _listeners.remove(listener); &#125; int get listenerCount =&gt; _listeners.length; @protected void notifyListeners() &#123; if (_microtaskVersion == _version) &#123; _microtaskVersion++; scheduleMicrotask(() &#123; _version++; _microtaskVersion = _version; _listeners.toList().forEach((VoidCallback listener) =&gt; listener()); &#125;); &#125; &#125;&#125; Model继承了Listenable, 值在改变的时候调用notifyListeners既可以通知到所有的监听器. class ScopedModel&lt;T extends Model&gt; extends StatelessWidget12345678910111213141516171819202122232425262728293031323334353637class ScopedModel&lt;T extends Model&gt; extends StatelessWidget &#123; final T model; final Widget child; ScopedModel(&#123;@required this.model, @required this.child&#125;) : assert(model != null), assert(child != null); @override Widget build(BuildContext context) &#123; return AnimatedBuilder( animation: model, builder: (context, _) =&gt; _InheritedModel&lt;T&gt;(model: model, child: child), ); &#125; // 找到 ScopeModel, 并且让子节点和祖先节点建立依赖 static T of&lt;T extends Model&gt;( BuildContext context, &#123; bool rebuildOnChange = false, &#125;) &#123; final Type type = _type&lt;_InheritedModel&lt;T&gt;&gt;(); Widget widget = rebuildOnChange ? context.inheritFromWidgetOfExactType(type) : context.ancestorInheritedElementForWidgetOfExactType(type)?.widget; if (widget == null) &#123; throw ScopedModelError(); &#125; else &#123; return (widget as _InheritedModel&lt;T&gt;).model; &#125; &#125; static Type _type&lt;T&gt;() =&gt; T;&#125; 通知方法 作者在构造ScopedModel的时候, 使用了AnimationBuilder, 这里会注册一个监听器到 Model中, 然后每一次值的改变都会调用AnimationBuilder.builder方法, 然后就会触发InherientWidget的改变, 根据updateShouldNotify来决定是否通知子孙控件更新, 但是在这里我们并没有看到InherientWidget的影子, 让我们接着往下看. class _InheritedModel&lt;T extends Model&gt; extends InheritedWidget12345678910111213class _InheritedModel&lt;T extends Model&gt; extends InheritedWidget &#123; final T model; final int version; _InheritedModel(&#123;Key key, Widget child, T model&#125;) : this.model = model, this.version = model._version, super(key: key, child: child); @override bool updateShouldNotify(_InheritedModel&lt;T&gt; oldWidget) =&gt; (oldWidget.version != version);&#125; 看到这个类, 我们就可以发现作者的实现方式了, _InheritedModel继承自InheritedWidget, 上方ScopedModel.build()方法, 里面就返回了该inherientWidget对象, 但是与上方的例子还缺少子类对父类进行依赖的一步. class ScopedModelDescendant&lt;T extends Model&gt; extends StatelessWidget12345678910111213141516171819202122232425262728typedef Widget ScopedModelDescendantBuilder&lt;T extends Model&gt;( BuildContext context, Widget child, T model,);class ScopedModelDescendant&lt;T extends Model&gt; extends StatelessWidget &#123; final ScopedModelDescendantBuilder&lt;T&gt; builder; final Widget child; final bool rebuildOnChange; ScopedModelDescendant(&#123; @required this.builder, this.child, this.rebuildOnChange = true, &#125;); @override Widget build(BuildContext context) &#123; return builder( context, child, ScopedModel.of&lt;T&gt;(context, rebuildOnChange: rebuildOnChange), ); &#125;&#125; ScopedModelDescendant就是ScopedModel的子孙, 那么可以看到它的 Build方法, 里面有调用ScopedModel.of&lt;T&gt;(context, rebuildOnChange: rebuildOnChange), 我们把这个方法在拿出来看一下: 123456789101112131415161718static T of&lt;T extends Model&gt;( BuildContext context, &#123; bool rebuildOnChange = false,&#125;) &#123; final Type type = _type&lt;_InheritedModel&lt;T&gt;&gt;(); Widget widget = rebuildOnChange ? context.inheritFromWidgetOfExactType(type) : context.ancestorInheritedElementForWidgetOfExactType(type)?.widget; if (widget == null) &#123; throw ScopedModelError(); &#125; else &#123; return (widget as _InheritedModel&lt;T&gt;).model; &#125;&#125;static Type _type&lt;T&gt;() =&gt; T; 到这里, 就可以发现它和inherient做法相同了, 首先获取到InheritedWidget的类型, _type&lt;_InheritedModel&lt;T&gt;&gt;()得到_InheritedModel&lt;T&gt;, 然后判断是否需要在改变的时候重绘, 默认是True, 如果需要重绘就会调用inheritFromWidgetOfExactType去建立依赖, 如果为false, 则会调用ancestorInheritedElementForWidgetOfExactType, 这个方法不会建立依赖, 所以在改变的时候不会收到通知并重绘, 官方的注释有这么一句:This method does not establish a relationship with the target in the way that [inheritFromWidgetOfExactType] does. 最后贴一下作者提供的小例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import 'package:flutter/material.dart';import 'package:scoped_model/scoped_model.dart';void main() &#123; CounterModel model = CounterModel(); runApp(MyApp( model: model, ));&#125;class MyApp extends StatelessWidget &#123; final CounterModel model; const MyApp(&#123;Key key, @required this.model&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // At the top level of our app, we'll, create a ScopedModel Widget. This // will provide the CounterModel to all children in the app that request it // using a ScopedModelDescendant. return ScopedModel&lt;CounterModel&gt;( model: model, child: MaterialApp( title: 'Scoped Model Demo', home: CounterHome('Scoped Model Demo'), ), ); &#125;&#125;// Start by creating a class that has a counter and a method to increment it.//// Note: It must extend from Model.class CounterModel extends Model &#123; int _counter = 0; int get counter =&gt; _counter; void increment() &#123; // First, increment the counter _counter++; // Then notify all the listeners. notifyListeners(); &#125;&#125;class CounterHome extends StatelessWidget &#123; final String title; CounterHome(this.title); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('You have pushed the button this many times:'), // Create a ScopedModelDescendant. This widget will get the // CounterModel from the nearest parent ScopedModel&lt;CounterModel&gt;. // It will hand that CounterModel to our builder method, and // rebuild any time the CounterModel changes (i.e. after we // `notifyListeners` in the Model). ScopedModelDescendant&lt;CounterModel&gt;( builder: (context, child, model) &#123; return Text( model.counter.toString(), style: Theme.of(context).textTheme.display1, ); &#125;, ), ], ), ), // Use the ScopedModelDescendant again in order to use the increment // method from the CounterModel floatingActionButton: ScopedModelDescendant&lt;CounterModel&gt;( builder: (context, child, model) &#123; return FloatingActionButton( onPressed: model.increment, tooltip: 'Increment', child: Icon(Icons.add), ); &#125;, ), ); &#125;&#125; 这里也能验证我们上方所分析的, 首先需要构建 ScopedModel, 然后共享状态的子孙节点通过ScopedModelDescendant来添加.","link":"/2019/06/22/Flutter_scoped_model源码阅读/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/30/hello-world/"},{"title":"Flutter-完成一个图片APP","text":"自从 Flutter 推出之后, 一直是备受关注, 有看好的也有不看好的, 作为移动开发人员自然是要尝试一下的(但是它的嵌套写法真的难受), 本着学一个东西, 就一定要动手的态度, 平时又喜欢看一些猫狗的图片, 就想着做一个加载猫狗图片你的 APP, 界面图如下(界面不是很好看). 主要模块 NetWorkapi.dart文件中, 分别定义了DogApi, CatApi两个类, 一个用于处理获取猫的图片的类, 一个用于处理狗的图片的类. http_request.dart文件封装了Http请求, 用于发送和接收数据. url.dart文件封装了需要用到的Api接口, 主要是为了方便和统一管理而编写. Models文件夹下分别定义不同API接口返回数据的模型. 图片页瀑布流使用的flutter_staggered_grid_view库, 作者自定义了Delegate计算布局, 使用起来非常简单. 123456789101112131415161718192021222324252627282930313233343536373839404142434445Widget scene = new StaggeredGridView.countBuilder( physics: BouncingScrollPhysics(), itemCount: this.breedImgs != null ? this.breedImgs.urls.length : 0, mainAxisSpacing: 4.0, crossAxisSpacing: 4.0, crossAxisCount: 3, itemBuilder: (context, index) &#123; return new GestureDetector( onTapUp: (TapUpDetails detail) &#123; // 展示该品种的相关信息 dynamic breed = this.breeds[this.selectedIdx].description; // TODO: 取出当前点击的然后所有往后的 List&lt;String&gt; unreadImgs = new List&lt;String&gt;(); for (int i = index; i &lt; this.breedImgs.urls.length; i++) &#123; unreadImgs.add(this.breedImgs.urls[i]); &#125; AnimalImagesPage photoPage = new AnimalImagesPage( listImages: unreadImgs, breed: this.breeds[this.selectedIdx].name, imgType: \"Cat\", petInfo: this.breeds[this.selectedIdx], ); Navigator.of(context) .push(new MaterialPageRoute(builder: (context) &#123; return photoPage; &#125;)); &#125;, child: new Container( width: 100, height: 100, color: Color(0xFF2FC77D), //Colors.blueAccent, child: new CachedNetworkImage( imageUrl: this.breedImgs.urls[index], fit: BoxFit.fill, placeholder: (context, index) &#123; return new Center(child: new CupertinoActivityIndicator()); &#125;, ), ), ); &#125;, // 该属性可以控制当前 Cell 占用的空间大小, 用来实现瀑布的感觉 staggeredTileBuilder: (int index) =&gt; new StaggeredTile.count(1, index.isEven ? 1.5 : 1), ); 组装PickerView 系统默认的 PickerView 在每一次切换都会回调, 而且没有确定和取消事件,如果直接使用会造成频繁的网络请求, 内存消耗也太快, 所以组装了一下, 增加确定和取消才去执行网络请求, 这样就解决了这个问题. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Widget column = Column( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ new Row( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ new Container( width: MediaQuery.of(context).size.width, height: 40, child: new Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ new Padding( padding: EdgeInsets.only(left: 10.0), child: new GestureDetector( onTapUp: (detail) &#123; // 点击了确定按钮, 退出当前页面 Navigator.of(context).pop(); // 回调操作 this.submit(this.selectedIndex); &#125;, child: new Text( \"确定\", style: TextStyle( decoration: TextDecoration.none, color: Colors.white, fontSize: 18), ), ), ), new Padding( padding: EdgeInsets.only(right: 10.0), child: new GestureDetector( onTapUp: (detail) &#123; // 点击了确定按钮, 退出当前页面 Navigator.of(context).pop(); &#125;, child: new Text( \"取消\", style: TextStyle( decoration: TextDecoration.none, color: Colors.white, fontSize: 18), ), ), ) ], ), ), ], ), new Container( height: 1, color: Colors.white, ), // Picker new Expanded( child: new CupertinoPicker.builder( backgroundColor: Colors.transparent, itemExtent: 44, childCount: this.names.length, onSelectedItemChanged: (int selected) &#123; this.selectedIndex = selected; this.onSelected(selected); &#125;, itemBuilder: (context, index) &#123; return new Container( width: 160, height: 44, alignment: Alignment.center, child: new Text( this.names[index], textAlign: TextAlign.right, style: new TextStyle( color: Colors.white, fontSize: 16, decoration: TextDecoration.none), ), ); &#125;), ) ],); 详情页 Column 包含 ListView 详情页中, 上方是一个图片, 下方是关于品种的相关信息, 猫下方是通过 API获取到的属性进行一个展示, 需要注意一点是, 如果Column封装了MainAxis相同方向的滚动控件, 必须设置Width/Height, 同理, Row也是需要注意这一点的. 我在这里的做法是通过一个Container包裹 ListView. 123456new Container( margin: EdgeInsets.only(bottom: 10, top: 10), height: MediaQuery.of(context).size.height - MediaQuery.of(context).size.width / 1.2 - 80, width: MediaQuery.of(context).size.width, child: listView,), 图片动画 这一部分稍微复杂一些, 首先需要监听滑动的距离, 来对图片进行变换, 最后根据是否达到阈值来进行切换动画, 这里我没有实现在最后一张和第一张图片进行切换以至于可以无限循环滚动, 我在边界阈值上只是阻止了下一步动画. 动画我都是通过Matrix4来设置不同位置的属性, 它也能模拟出 3D 效果, 动画的变换都是Tween来管理. 123456789101112131415161718192021222324252627282930313233343536void _initAnimation() &#123; // 透明度动画 this.opacityAnimation = new Tween(begin: 1.0, end: 0.0).animate( new CurvedAnimation( parent: this._nextAnimationController, curve: Curves.decelerate)) ..addListener(() &#123; this.setState(() &#123; // 通知 Fluter Engine 重绘 &#125;); &#125;); // 翻转动画 // 第三个值是角度 var startTrans = Matrix4.identity()..setEntry(3, 2, 0.006); var endTrans = Matrix4.identity() ..setEntry(3, 2, 0.006) ..rotateX(3.1415927); this.transformAnimation = new Tween(begin: startTrans, end: endTrans) .animate(new CurvedAnimation( parent: this._nextAnimationController, curve: Curves.easeIn)) ..addListener(() &#123; this.setState(() &#123;&#125;); &#125;); // 缩放 var saveStartTrans = Matrix4.identity()..setEntry(3, 2, 0.006); // 平移且缩放 var saveEndTrans = Matrix4.identity() ..setEntry(3, 2, 0.006) ..scale(0.1, 0.1) ..translate(-20.0, 20.0); // MediaQuery.of(context).size.height this.saveToPhotos = new Tween(begin: saveStartTrans, end: saveEndTrans) .animate(new CurvedAnimation( parent: this._saveAnimationController, curve: Curves.easeIn)) ..addListener(() &#123; this.setState(() &#123;&#125;); &#125;);&#125; Widget引用这个属性来执行动画. 1234567891011121314151617181920212223242526272829303132333435363738Widget pet = new GestureDetector( onVerticalDragUpdate: nextUpdate, onVerticalDragStart: nextStart, onVerticalDragEnd: next, child: new Transform( transform: this.dragUpdateTransform, child: Container( child: new Transform( alignment: Alignment.bottomLeft, transform: transform, child: new Opacity( opacity: opacity, child: Container( width: MediaQuery.of(context).size.width / 1.2, height: MediaQuery.of(context).size.width / 1.5 - 30, child: new Padding( padding: EdgeInsets.all(0), child: new CachedNetworkImage( imageUrl: this.widget.listImages[item], fit: BoxFit.fill, placeholder: (context, content) &#123; return new Container( width: MediaQuery.of(context).size.width / 2.0 - 40, height: MediaQuery.of(context).size.width / 2.0 - 60, color: Color(0xFF2FC77D), child: new Center( child: new CupertinoActivityIndicator(), ), ); &#125;, ), ), ), ), ), ), ), ); Firebase_admob注意: 这里需要去 firebase 官网注册 APP, 然后分别下载 iOS, Android 的配置文件放到指定的位置, 否则程序启动的时候会闪退. iOS info.plist: GADApplicationIdentifier也需要配置, 虽然在 Dart 中会启动的时候就注册ID, 但是这里也别忘了配置. Android Manifst.xml 也需要配置 123&lt;meta-data android:name=\"com.google.android.gms.ads.APPLICATION_ID\" android:value=\"\"/&gt; 这里说一下我因为个人编码导致的问题, 我尝试自己来控制广告展示, 加了一个读秒跳过按钮(想强制观看一段时间), 点击跳过设置setState, 但是在 build 方法中又请求了广告, 导致了一个死循环, 最后由于请求次数过多还没有设置自己的设备为测试设备也不是使用的测试ID, 账号被暂停了, 所以大家使用的时候要避免这个问题, 尽量还是将自己的设备添加到测试设备中. 使用的话比较简单(官方的演示代码直接复制也可以用). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class AdPage &#123; MobileAdTargetingInfo targetingInfo; InterstitialAd interstitial; BannerAd banner; void initAttributes() &#123; if (this.targetingInfo == null) &#123; this.targetingInfo = MobileAdTargetingInfo( keywords: [\"some keyword for your app\"], // 防止被Google 认为是无效点击和展示. testDevices: [\"Your Phone\", \"Simulator\"]); bool android = Platform.isAndroid; this.interstitial = InterstitialAd( adUnitId: InterstitialAd.testAdUnitId, targetingInfo: this.targetingInfo, listener: (MobileAdEvent event) &#123; if (event == MobileAdEvent.closed) &#123; // 点击关闭 print(\"InterstitialAd Closed\"); this.interstitial.dispose(); this.interstitial = null; &#125; else if (event == MobileAdEvent.clicked) &#123; // 关闭 print(\"InterstitialAd Clicked\"); this.interstitial.dispose(); this.interstitial = null; &#125; else if (event == MobileAdEvent.loaded) &#123; // 加载 print(\"InterstitialAd Loaded\"); &#125; print(\"InterstitialAd event is $event\"); &#125;, );// this.banner = BannerAd(// targetingInfo: this.targetingInfo,// size: AdSize.smartBanner,// listener: (MobileAdEvent event) &#123;// if (event == MobileAdEvent.closed) &#123;// // 点击关闭// print(\"InterstitialAd Closed\");// this.interstitial.dispose();// this.interstitial = null;// &#125; else if (event == MobileAdEvent.clicked) &#123;// // 关闭// print(\"InterstitialAd Clicked\");// this.interstitial.dispose();// this.interstitial = null;// &#125; else if (event == MobileAdEvent.loaded) &#123;// // 加载// print(\"InterstitialAd Loaded\");// &#125;// print(\"InterstitialAd event is $event\");// &#125;); &#125; &#125; @override void show() &#123; // 初始化数据 this.initAttributes(); // 然后控制跳转 if (this.interstitial != null) &#123; this.interstitial.load(); this.interstitial.show( anchorType: AnchorType.bottom, anchorOffset: 0.0, ); &#125; &#125;&#125; 项目比较简单, 但是编写的过程中也遇到了许多问题, 慢慢解决的过程也学到了挺多. 一些资源Public APIs代码地址","link":"/2019/06/21/Flutter_完成一个图片APP/"},{"title":"遗传算法","text":"遗传算法1、遗传算法理论的由来 2、生物学的启发 3、遗传算法定义 4、遗传算法具体步骤 * 初始化 * 适应度函数 * 选择 * 交叉 * 变异5、遗传算法的应用 * 特征选取类比我们先假设一个情景，现在你是一国之王，为了让你的国家免于灾祸，你实施了一套法案： 1. 你选出所有的好人，要求其通过生育来扩大国民数量。 2. 这个过程持续进行了几代。 3. 你将发现，你已经有了一整群的好人。这个例子虽然不太可能，但是我用它是想帮助你理解概念。也就是说，我们改变了输入值（比如：人口），就可以获得更好的输出值（比如：更好的国家）。现在，我假定你已经对这个概念有了大致理解，认为遗传算法的含义应该和生物学有关系。那么我们就快速地看一些小概念，这样便可以将其联系起来理解。 过程回到前面讨论的那个例子，并总结一下我们做过的事情。 首先，我们设定好了国民的初始人群大小。 然后，我们定义了一个函数，用它来区分好人和坏人。 再次，我们选择出好人，并让他们繁殖自己的后代。 最后，这些后代们从原来的国民中替代了部分坏人，并不断重复这一过程。 遗传算法实际上就是这样工作的，也就是说，它基本上尽力地在某种程度上模拟进化的过程。 因此，为了形式化定义一个遗传算法，我们可以将它看作一个优化方法，它可以尝试找出某些输入，凭借这些输入我们便可以得到最佳的输出值或者是结果。遗传算法的工作方式也源自于生物学，具体流程见下图： 算法的思想是非常简单的, 但是作用却是非常大的. 从一个实际问题来求解.问题描述 名字\\属性 重量/kg 价值 睡袋 15 15 绳子 3 7 折叠刀 2 10 火把 5 5 瓶子 9 8 葡萄糖 20 17 有一个可以装30kg的背包, 怎么装效益最高. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 背包问题求解(动态规划也是求解这种问题的一个好方法)max_weights = 30weights = np.array([15, 3, 2, 5, 9, 20])values = np.array([15, 7, 10, 5, 8, 17])## 随机初始化一个族群features = len(weights)# 初始样本数init_sample_nums = np.random.randint(int(2 ** features / 3), 2 ** features)samples = np.ones((init_sample_nums, features))# 随机给定特性(基因)for sample in range(init_sample_nums): probs = np.random.normal(0, 1, features) &gt; 0.5 random_sample = np.zeros((features, )) random_sample[probs] = 1 samples[sample] = random_sample# 定义函数去筛选## 筛选, 去除超过总重量的def remove_the_not_fitness_sample(samples): total_weights = np.sum(samples, axis=1) not_fitness = total_weights &gt; 30 # 保留下来的 fitness = samples[~not_fitness] return fitness# 评分函数### 用于族内对比 def compare_score(samples, remove=2): # 如果直接通过最高评分判断 scores = np.zeros((len(samples, ))) for sample_index in range(len(samples)): has_feature_index = samples[sample_index] == 1 scores[sample_index] = np.sum(weights[has_feature_index]) # 排分 # 从小到大 sort_scores = np.argsort(scores) # 默认剔除最小的两个 return samples[sort_scores[2:]] ## 杂交def crossover(samples, pairs=5, feature_prob=0.5): # 随机选取样本开始杂交 # 每一次随机选择5对开始杂交 features = len(samples[0]) copy_samples = np.copy(samples) for pair_index in range(pairs): selected = np.random.choice(range(len(samples)), 2) # 每一个位置的Gene有多大的可能性会进行杂交 cross_indexes = np.random.normal(0, 1, features) &gt; feature_prob print(cross_indexes, selected) for cross_index in range(len(cross_indexes)): if cross_indexes[cross_index]: samples[selected[0]][cross_index] = samples[selected[1]][cross_index] copy_samples = np.append(copy_samples, samples[selected], axis=0) return copy_samples## 变异def mutation(samples, feature_unmutation_prob=0.8): # 每个基因(feature)的变异几率为0.2 for sample in samples: for feature in range(len(sample)): if np.random.normal(0, 1, 1) &gt; feature_unmutation_prob: sample[feature] = 0 if sample[feature] else 1 return samples# 执行生物论fitness = remove_the_not_fitness_sample(samples)filter_samples = compare_score(samples)crossover_samples = crossover(filter_samples)mutation_samples = mutation(crossover_samples)","link":"/2019/05/30/遗传算法/"}],"tags":[],"categories":[]}